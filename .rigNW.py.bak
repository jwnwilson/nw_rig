# -*- coding: utf-8 -*-

"""
To do:
- Need inhertance of modules - done
- Need to have multiple instances supported and namespaces for items in containers
- Needs more sub controls for starters
- Starter direction needs to be influenced by other starter controls
- All inputs and outputs refreshed when connection queried can be optimised
- All components must be stored in containers
- Need to store connections -done
- Option to go from build back to start and via versa
- Require rename option
- Create a defomation menu / skinning menu

- Require a pickle / refresh python module data function so scene data can be reloaded into tool

- Create menu
	- New are you sure box
	- Save all
	- Load all
- Start Menu
	- cleaner menu
- Build Menu
	- Save
		- save control shapes
		- save connections between objects
		
		
		
"""

MAYA_STANDALONE = 0
DEBUG =0

if MAYA_STANDALONE or DEBUG:
	import maya.standalone
	maya.standalone.initialize()

import maya.cmds as cmds
import maya.mel as mel
import maya.OpenMayaAnim as OpenMayaAnim
import ctypes
import os
import sys
import maya.OpenMaya as OpenMaya
from functools import wraps

PATH_INDICE = 0
ROOT_PATH=[]
PACKAGES ={}

"""
Add python directory to sys.path if necessary depending on operating system
"""
if os.name == 'posix':
	FILE_PATH = "/media/WALKMAN/Python/NWRig/"
elif os.name == 'nt':
	FILE_PATH = "F:/Documents and Settings/Noel Wilson/My Documents/Git/NWRig/"
if FILE_PATH not in sys.path:
	sys.path.append( FILE_PATH )

"""
source utilities first remove duplicate code in __init__
source packages
"""
import NWUtilitiesPackage.NWFileUtilities as fileUtil
import NWUtilitiesPackage.NWUtilities as util
reload(fileUtil)
reload(util)

"""
Dynamic importing of modules
"""
PACKAGES = fileUtil.import_packages( FILE_PATH )
for key in PACKAGES.keys():
	globals()[key] = PACKAGES[key]

class Command:
		def __init__(self,name): 
				self.name = name
				
# contains rig system
class RigNW:
		"""
			Manages project and loads gui / builds the rig
		"""
		def __init__(self, name, **kwargs):
				classArgs = {"UIFile":"default.py","rebuildUI":True}
				#classArgs =  dict(classArgs.items() + kwargs.items())
				classArgs =	 util.defaultArgs( classArgs,  kwargs)
				self.Modules = {}
				self.connections = {}
				self.name = name
				self.UIFile =  classArgs["UIFile"]
				if classArgs["rebuildUI"]:
					self.UI = self.initialiseUI()
				
		def initialiseUI(self):
			""" 
				read in UIFile
			"""
			windowDir = NWWindowPackage.__path__
			filePath = (windowDir[0] + "/blueprints/" +self.UIFile)
			FILE = open(filePath,"rU")
			command = FILE.read()
			FILE.close()
			exec command
			
			return window
			
		# ------------------------		
		# Load save data
		# ------------------------
		def loadStartData(self):
			"""
				Loads start data onto starters
			"""
			# open file from path in UI
			self.UI.getFilePath()
			filePath = (str(self.UI.filePath) + "start.txt")
			FILE = open(filePath,"rU")			  
			
			for line in FILE:
				startDataLine = line.split()
				startObject = startDataLine[0]
				translate = [ float( startDataLine[1] ), float( startDataLine[2] ), float( startDataLine[3] ) ]
				rotate = [ float( startDataLine[4] ), float( startDataLine[5] ), float( startDataLine[6] ) ]
				scale = [ float( startDataLine[7] ), float( startDataLine[8] ), float( startDataLine[9] ) ]
				if cmds.objExists(startObject):
					util.checkSetCompoundAttr( (startObject + ".t"), translate )
					util.checkSetCompoundAttr( (startObject + ".r"), rotate )
					util.checkSetCompoundAttr( (startObject + ".s"), scale )
			FILE.close()
			print ("Loaded start data from : " + filePath)
					
		def saveStartData(self):
			"""
				Saves start data onto starters
			"""
			objects = self.getRegisteredObjects("regStartTransform")
			self.UI.getFilePath()  
			filePath = (str(self.UI.filePath) + "start.txt")
			writeData = ""
			
			for object in objects:
				translate = util.getFirst(cmds.getAttr( (object + ".t") ) )
				rotate = util.getFirst( cmds.getAttr( (object + ".r") ) )
				scale = util.getFirst( cmds.getAttr( (object + ".s") ) )
				writeLine = (object + " " + str(translate[0]) + " " + str(translate[1]) + " " + str(translate[2]) + " " +
											str(rotate[0]) + " " + str(rotate[1]) + " " + str(rotate[2]) + " " +
											str(scale[0]) + " " + str(scale[1]) + " " + str(scale[2]) + "\n")
				writeData += writeLine
			FILE = open(filePath,"wb")
			startData = FILE.write(writeData)
			FILE.close()
			print ("Saving start data to : " + filePath)
			
        def saveBuildData(self):
            """
                Saves registered build Data
            """
            
            self.UI.getFilePath()  
			filePath = (str(self.UI.filePath) + "buildData.txt")
			writeData = ""
			
            # Get registered control shapes
            # Save control shapes
            # Get container data
            moduleList = self.getModules()
            # for each module
            for module in moduleList:
                # get registered attributes
                writeData += (module + "\n")
                registeredAttrs = self.Modules[module].getRegisteredAttributes()
                
                for regAttr in registeredAttrs:
                    writeLine = ""
                    attr = (self.Modules[module].container + "." + regAttr )
                    attrType = cmds.getAttr(attr, type = True)
                    attrData = cmds.getAttr(attr)
                    # save container data
                    
                    # if attr == message store attribute name and type
                    if attrType == "message":
                        writeLine += ( attr + " " + attrType ) 
                    # if attr == string store attribute name and data
                    elif attrType == "stringArray":
                        writeLine += ( attr + " " + attrType + " " + attrData ) 
                    # if attr == etc store attribute name and data
                    else:
                        writeLine += ( attr + " " + attrType + " " + attrData ) 
                    writeLine += ( + "\n")
                    writeData += writeLine
                    
            FILE = open(filePath,"wb")
			startData = FILE.write(writeData)
			FILE.close()
			print ("Saving start data to : " + filePath)
            
        def loadBuildData(self):
            """
                Load registered build data
            """
			
		def getRegisteredObjects(self, registry):
			"""
				finds all registered starter objects from containters
				registry is attribute stored on containers connected to 
				desired objects
			"""
			starterTransforms =[]
			# Get all containers
			containers = self.getModuleContainers()
			# iterate through and get staters from attribute connections
			for container in containers:
				if cmds.objExists( (container + "." + registry) ):
					containerStartTransforms = cmds.listConnections( (container + "." + registry) )
					starterTransforms += containerStartTransforms
			return starterTransforms
		# ------------------------		
		# Module functions
		# ------------------------
		def new(self, **kwards):
			"""
				create initial hierarchy for rig
			"""
			self.__init__(self.name, rebuildUI = False)
			name = self.name
			rootMod = NWRoot.NWRoot(self.name)
			self.Modules["root"] = rootMod
			self.Modules[self.name] = rootMod
			self.Modules["root"].start()
			self.rootGrp = self.Modules["root"].rootGrp
			
		def moduleExists(self, name):
			if cmds.objExists(name + "_CNT"):
				return True
			else:
				return False
		
		def rootExists(self):
			if self.moduleExists(self.name):
				return True
			else:
				return False
				
		def getModules(self):
		    moduleKeys = self.Modules.keys()
		    modules = []
			for key in moduleKeys:
			    name  = self.Modules[key].name
			    if self.moduleExists(name):
			        modules.append(name)
            return modules
				
		def getRootModule(self):
			return self.getModule(self.name)
		
		def checkMethod(self,name, method):
			"""
				Check method variable set after completion
			"""
			if method == "start" and self.Modules[name].startVar == 0:
					return True
			if method == "build" and self.Modules[name].buildVar == 0:
					return True
			return False
		def startModule(self,module):
			"""
				Run start method for module
			"""
			# get module name
			windowElement = self.UI.inputs["startTextField"]
			name = cmds.textField(windowElement.fullPath, q=True,tx=True)
			
			# Check that root is built
			if self.rootExists() == False:
				self.new()
			
			# Create command
			if self.moduleExists(name) == False:
				command = ("mod = " + str(module) + "." + str(module) + "('"+ name +"')")
				exec command
				try:
					mod.start()
				except:
					print "Unexpected error:", sys.exc_info()[0]
				self.Modules[mod.name] = mod
				cmds.parent(mod.rootGrp, self.Modules["root"].groups["modules"])
				cmds.container( self.Modules["root"].container, edit=True, an= mod.container)
			else:
				print ("Module \"" + name + "\" already exists!")
				
		def buildModule(self,args):
			"""
				Run build method for module
			"""
			# get module name
			defaultArgs = {"name":"default"}
			functArgs =	 util.defaultArgs( defaultArgs,	 args)
			name = functArgs["name"]
			
			# Check that root is built
			if self.rootExists() == False:
					cmds.error("Root container not found during build")
			self.refreshModuleList()
			
			# check module exists and build has not been run
			if self.moduleExists(name) and self.checkMethod(name, "build"):
				try:
					mod = self.Modules[name]
					mod.build()
				except:
					print "Unexpected error:", sys.exc_info()
			else:
				print ("Module \"" + name + "\" already built!")
				
		def refreshModuleList(self):
			"""
				Clears and refreshes module instances
			"""
			rootCnt = (self.name + "_CNT")
			rootModule = {}
			# check if module list is empty
			if len(self.Modules) == 0:
				# Find root and find it's children
				if self.rootExists():
					# populate module list
					rootModule["root"] = self.reloadModule(rootCnt)
					childModules = self.getContainerChildren(rootCnt)
					self.Modules = util.defaultArgs( rootModule,  childModules)
				else:
					smds.error("Root containter not found for refresh")
		# ------------------------		
		# Container functions
		# ------------------------
		def getModuleContainers(self):
			"""
				returns list of all container modules
			"""
			rootCnt = ""
			containerList= []
			# Get root container
			if self.rootExists():
				containerList.append( self.getRootModule() )
				contents= cmds.container(containerList[0], query= True, nodeList= True)
				if contents == None:
					return containerList
				for item in contents:
					if cmds.objectType(item) == "container":
						containerList.append( item )
				return containerList
				
			return containerList
				
		def getContainerChildren(self,cont):
			"""
				Finds all children containers of passed container
			"""
			containers = {}
			if cmds.objExists(cont):
				# populate module list
				contents = cmds.container(cont, query= True, nodeList= True)
				if contents == None:
					return containers
				for item in contents:
					if cmds.objectType(item) == "container":
						containers[util.removeSuffix(item)] = self.reloadModule(item)
						# combine and overwrite lists
						containers = dict(containers.items() + (self.getContainerChildren(item)).items())
				return containers
			else:
				cmds.error("Root containter not found for refresh")
		
		def reloadModule(self,module):
			"""
				Gets data from container and rebuilds python object
			"""
			moduleType = util.getString(module, "type")
			command = ("module = " + str(moduleType) + "." + str(moduleType) + "('"+ util.removeSuffix(module) +"')")
			exec command
			return module
		# ------------------------		
		# input output functions
		# ------------------------
		def updateInputOutput(self):
			"""
				iterates through modules updating inputs and puts
			"""
			for module in self.Modules.keys():
				self.Modules[module].updateInputOutputs()
				
		
		def getInput(self,module,key):
			"""
				Gets input from module
			"""
			self.updateInputOutput()
			return self.Modules[module].inputs[key]
		
		def getOutput(self,module,key):
			"""
				Gets input from module
			"""
			self.updateInputOutput()
			return self.Modules[module].outputs[key]
			
		def updateConnectionData(self):
			"""
				iterate through modules update data
			"""
			for module in self.Modules:
				module.updateConnectionData()
		
		def createConnection(self, inputModule, connectionKey):
			"""
				Connect objects based on connection data
			"""
			inputModule = self.Modules[inputModule]
			# Check connection exists
			if not inputModule.connections.has_key(connectionKey):
				cmds.error("Connection data not found")
			inputPlug = inputModule.connections[connectionKey]["input"]
			outputPlug = inputModule.connections[connectionKey]["output"]
			connectionAttr = inputModule.connections[connectionKey]["connectAttr"]
			connectionDataAttr = (connectionAttr + "_data")
			
			inputModule = inputPlug.split(".")[0]
			outputModule = outputPlug.split(".")[0]
			
			inputKey = util.getSuffix( inputPlug.split(".")[1] )
			outputey = util.getSuffix( outputPlug.split(".")[1] )
			
			input = self.getInput(inputModule, inputKey)
			output = self.getOutput(outputModule, outputey)
			
			# Get connection data
			connectionData = cmds.getAttr( (inputModule + "_CNT." + connectionDataAttr) )
			attrName = connectionData[3]
			type = attrName = connectionData[1]
			
			if type == "trans":
				cmds.parentConstraint(output,input, mo= False)
			elif type == "transMo":
				cmds.parentConstraint(output,input, mo= True)
			elif type == "pos":
				cmds.pointConstraint(output,input, mo= False)
			elif type == "posMo":
				cmds.pointConstraint(output,input, mo= True)
			elif type == "rot":
				cmds.orientConstraint(output,input, mo= False)
			elif type == "rotMo":
				cmds.orientConstraint(output,input, mo= True)
			elif type == "scale":
				cmds.scaleConstraint(output,input)
			elif type == "matrix":
				util.matrixConstraint(output, input, 0, {})
			elif type == "matrixMo":
				util.matrixConstraint(output, input, 1, {})
			elif type == "attr":
				cmds.connectAttr(output, input, f= True)
			else:
				cmds.error( ("Connection type not found on connectionAttr: " + connectionAttr) )
			
		def storeConnection(self, connectionKey, inputkey, outputPlug , type, attrName= "none"):
			"""
				Store connection between output to input on current module
			"""
			
			pass

if __name__ == "__main__":
	print "Starting test:"
	global NWRig
	NWRig = RigNW("nwRig")
